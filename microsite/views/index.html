<html>
	<head>
		<title> {{title}} </title>
		<meta charset="utf-8">
		<style>
		
			html,body{ margin: 0; padding: 0; }
		
		</style>
	</head>
	<body>

		<!-- - - - - - - - POINT SHADER - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  -->

		<script id="vs-point" type="x-shader/x-vertex">

			uniform sampler2D map;
			uniform float width;
			uniform float height;
			uniform float pointsize;

			float zoffset = 2048.0/4.0;

			varying vec2 vUv;
			varying vec3 vPos;
			varying vec3 vColor;
			varying float vDepth;

			float scale( float val, float in_min, float in_max, float out_min, float out_max ){
				return (val - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
			}

			void main() {
				// pass fragement-shader coords
				vPos = position; 
				// pass fragment-shader vertexColor
				vColor = color;
				// pass fragement-shader uv's ( to be used w/ texture map )
				vUv = uv;

				// use color from canvas as z-depth 
				vec4 depth = texture2D( map, uv );
				float d = ( depth.r + depth.g ) / 2.0;
				vDepth = d; // pass to fragment shader
				d = clamp( d, 0.6471, 1.0 );
				float z = (1.0-d) * 2048.0; 
				
				
				vec4 pos = vec4( position.x, position.y, -z+zoffset, 1.0 );
				
				float psize = scale(d, 0.6471, 1.0, 0.0, 50.0 );

				gl_PointSize = psize;
				gl_Position = projectionMatrix * modelViewMatrix * pos;
				// gl_Position = vec4(position, 1.0); // flat screen essentially 
			}


		</script>


		<script id="fs-point" type="x-shader/x-fragment">

			uniform sampler2D map;
			varying vec2 vUv;
			varying float vDepth;

			float scale( float val, float in_min, float in_max, float out_min, float out_max ){
				return (val - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
			}
			
			void main() {
				
				//float d = (vDepth - 0.6471) / 0.3529; // scale it
				float d = scale( vDepth, 0.6471, 1.0, 0.0, 1.0 );
				
				// float d;
				// if( vDepth < 0.6471 ) d = 0.0;
				// else d = 1.0;

				// float d = 1.0;
				// 
				float alpha;
				if(vDepth < 0.6471 ) alpha = 0.0;
				else alpha = 1.0;

				gl_FragColor = vec4( d, d, d, alpha );
				// gl_FragColor = vec4( 1.0 );
			
			}

		</script>
	
		<script src="libs/stats.min.js"></script>
		<script src="libs/three.min.js"></script>
		<script src="BB.min.js"></script>
		<script src="meshFromKinect.js"></script>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script> 
		<script>

			var sessionId = "{{id}}";
			var scene, camera, renderer; 
			var stats, axes;
			var clearColor = 0x000000;

			var KeyFrames = [];

			function base64ToUint16Array(base64) {
				var binary_string =  window.atob(base64);
				var len = binary_string.length;
				var shorts = new Uint16Array(len);
				//var bytes = new Uint8Array( len );
				var j = 0;
				for (var i = 0; i < len; i += 2) 
		        {
		        	shorts[j] = (binary_string.charCodeAt(i+1) << 8) | binary_string.charCodeAt(i);
					//bytes[i] = binary_string.charCodeAt(i);
					j++;
					// if( i == 0 ) console.log( binary_string[i], binary_string.charCodeAt(i) )
				}
				return shorts;
			}

			function _base64ToArrayBuffer(base64) {
			    var binary_string =  window.atob(base64);
			    var len = binary_string.length;
			    var bytes = new Uint8Array( len );
			    for (var i = 0; i < len; i++)        {
			        bytes[i] = binary_string.charCodeAt(i);
			    }
			    return bytes;
			}


			$.getJSON( "http://"+window.location.host+"/api/sessions?id="+sessionId, function( data ) {
				if (!data.error && data.data) {
					
					for (var i = 0; i < data.data.keyFrames.length; i++) {
						var decodedArray = _base64ToArrayBuffer( data.data.keyFrames[i].depthData );
						KeyFrames.push( decodedArray );
					};

					setup();
					draw();
				
				} else {
					console.log(data);
				}
			});

			function setup() {

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( clearColor );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.domElement.style.position = 'absolute';
				renderer.domElement.style.left = '0px';
				renderer.domElement.style.top = '0px';
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 50, window.innerWidth/window.innerHeight, 1, 10000 );
				camera.position.set( 0, 0, 250 );
				

				portrait = new meshFromKinect({
					polycount: 100,
					vertexShaderID: 'vs-point',
					fragmentShaderID: 'fs-point',
					type: 'point',
					pointsize: 2
				});
				portrait.newCanvasData = KeyFrames[0];
				portrait.tweenCanvasData( KeyFrames[0] );
				scene.add( portrait.mesh );

				// ----------------------- helpers ----------------------- debug ----------------------- 
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '90px';
				stats.domElement.style.width = "100px";
				stats.domElement.style.display = "none";
				document.body.appendChild( stats.domElement );
				//
				axes = new THREE.AxisHelper(150);
				axes.material.transparent = true;
				axes.material.opacity = 0.0;
				scene.add(axes);
				//
				var canvas = portrait.canvas;
				canvas.style.position = "absolute";
				canvas.style.display = "none";
				canvas.style.width = "100px";
				document.body.appendChild(canvas);

				/*
					+	: zoom camera in
					-	: zoom camera out
					C 	: change bg color
					S 	: toggle stats
				 */
				document.onkeypress = function(e){
					var e = window.event || e;
					// console.log(e.keyCode)

					if(e.keyCode==61) camera.position.z -= 25;	// +
					if(e.keyCode==45) camera.position.z += 25;	// -

					if(e.keyCode == 99 ){ // C ( to change background color )
						clearColor = (clearColor==0xffffff) ? 0x000000 : 0xffffff;
						renderer.setClearColor( clearColor );
					}
					if(e.keyCode == 115 ){ // S ( to toggle stats )
						if(stats.domElement.style.display=='none'){
							canvas.style.display  = stats.domElement.style.display = 'block';
							axes.material.opacity = 1.0;
						} else { 
							canvas.style.display  = stats.domElement.style.display = 'none';
							axes.material.opacity = 0.0;
						}
					}

				}

				window.onresize = function() {
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
					renderer.setSize( window.innerWidth, window.innerHeight );
				}
				window.onresize();
			}

			var frame = 0;
			var counter = 0;

			function draw() {
				requestAnimationFrame(draw);

				// if(typeof portrait !== 'undefined'){
				// 	portrait.texture.needsUpdate = true;
				// }

				portrait.mesh.rotation.y = Math.sin( performance.now()*0.0008 );

				counter++;
				if( counter % 240  == 0 ){
					frame++; if(frame>=KeyFrames.length) frame = 0;
					portrait.tweenCanvasData( KeyFrames[frame] );
				}

				renderer.render( scene, camera );
				stats.update();
			}


		</script>
	</body>
</html>