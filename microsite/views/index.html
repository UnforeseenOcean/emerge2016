<html>
	<head>
		<title> {{title}} </title>
		<meta charset="utf-8">
		<style>
		
			html,body{ margin: 0; padding: 0; }
		
		</style>
	</head>
	<body>

		<script id="vs" type="x-shader/x-vertex">

			uniform sampler2D map;
			uniform float width;
			uniform float height;
			uniform float pointsize;

			uniform float pmin;
			uniform float pmax;
			uniform float resthresh;
			uniform float time;

			float zoffset = 2048.0/4.0;

			varying vec2 vUv;
			varying vec3 vPos;
			varying vec3 vColor;
			varying float vDepth;

			float scale( float val, float in_min, float in_max, float out_min, float out_max ){
				return (val - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
			}

			float resYPsize( float rt, float val ){
				if( ceil(position.y) == ceil(480.0/50.0*rt) )return val;
				else return 0.0;
			}

			float resXPsize( float rt, float val ){
				if( ceil(position.x) == ceil(640.0/50.0*rt) ) return val;
				else return 0.0;
			}

			float resX1Psize(float rt, float val){
				if( mod( abs(ceil(position.x)), rt ) == 0.0 ) return val;
				else return 0.0;
			}

			float xWave(float t, float val){
				float st = abs( sin(t*0.001)*50.0 ) - 25.0 ;
				float x = ceil(position.x);
				float minSeg = ceil(640.0/50.0*(st-2.0));
				float maxSeg = ceil(640.0/50.0*(st+2.0));
				if( x >= minSeg && x <= maxSeg ) return val;
				else return 0.0;
			}


			void main() {
				// pass fragement-shader coords
				vPos = position; 
				// pass fragment-shader vertexColor
				vColor = color;
				// pass fragement-shader uv's ( to be used w/ texture map )
				vUv = uv;

				// use color from canvas as z-depth 
				vec4 depth = texture2D( map, uv );
				float d = ( depth.r + depth.g ) / 2.0;
				d = clamp( d, 0.6471, 1.0 );
				vDepth = d; // pass to fragment shader
				float z = (1.0-d) * 2048.0; 
				
				
				vec4 pos = vec4( position.x, position.y, -z+zoffset, 1.0 );
				
				float psize = scale(d, 0.6471, 1.0, pmin, pmax );
				
				// gl_PointSize = xWave( time, psize );
				gl_PointSize = psize;

				gl_Position = projectionMatrix * modelViewMatrix * pos;
			}


		</script>


		<script id="fs" type="x-shader/x-fragment">

			uniform sampler2D map;
			varying vec2 vUv;
			varying float vDepth;

			float scale( float val, float in_min, float in_max, float out_min, float out_max ){
				return (val - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
			}
			
			void main() {
				
				float d = scale( vDepth, 0.6471, 1.0, 0.2, 1.0 );				

				float alpha;
				if(vDepth <= 0.6471 ) alpha = 1.0;
				else alpha = 1.0;

				gl_FragColor = vec4( d-0.25, d-(d*2.0), d, 1.0 );
			
			}

		</script>
	
		<script src="libs/stats.min.js"></script>
		<script src="libs/three.min.js"></script>
		<script src="libs/dat.gui.bb.min.js"></script>
		<script src="BB.min.js"></script>
		<script src="MeshFromDepth.js"></script>
		<script src="DepthFromKinect.js"></script>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script> 
		<script>

			var sessionId = "{{id}}";
			var scene, camera, renderer; 
			var wireframe, pointcloud, depth;
			var stats, axes;
			var clearColor = 0x000000;

			var KeyFrames = [];

			function str2Uint8Array( base64 ) {
			    var bstr =  window.atob( base64 );
			    var len = bstr.length;
			    var arr = new Uint8Array( len );
			    for (var i = 0; i < len; i++) arr[i] = bstr.charCodeAt(i);
			    return arr;
			}

			$.getJSON( "http://"+window.location.host+"/api/sessions?id="+sessionId, function( data ) {
				if (!data.error && data.data) {
					
					for (var i = 0; i < data.data.keyFrames.length; i++) {
						var decodedArray = str2Uint8Array( data.data.keyFrames[i].depthData );
						KeyFrames.push( decodedArray );
					};

					setup();
					draw();
					// makegui();
				
				} else {
					console.log(data);
				}
			});

			function setup() {

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( clearColor );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.domElement.style.position = 'absolute';
				renderer.domElement.style.left = '0px';
				renderer.domElement.style.top = '0px';
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 50, window.innerWidth/window.innerHeight, 1, 10000 );
				camera.position.set( 0, 0, 650 );
				
				//

				depth = new DepthFromKinect( 640, 480, KeyFrames[0] );

				wireframe = new MeshFromDepth({
					depthData: depth.canvas,
					scene: scene,
					vertexShader: 'shaders/glazewire-v.glsl',
					fragmentShader: 'shaders/glazewire-f.glsl',
					type: 'mesh',
					wireframe: true,
					polycount: 20,
					uniforms: [
						{ name: "time", type:"f", value: 0.0 },
					]
				});

				pointcloud = new MeshFromDepth({
					depthData: depth.canvas,
					scene: scene,
					// fragmentShaderID: 'fs',
					// vertexShaderID: 'vs',
					vertexShader: 'shaders/huepoints-v.glsl',
					fragmentShader: 'shaders/huepoints-f.glsl',				
					type: 'point',
					polycount: 100,
					uniforms: [
						{ name: "time", type:"f", value: 0.0 },
						{ name: "pmax", type:"f", value: 1.0 },
						{ name: "resthresh", type:"f", value: 1.0 }
					]
				});


				// ----------------------- helpers ----------------------- debug ----------------------- 
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '90px';
				stats.domElement.style.width = "100px";
				stats.domElement.style.display = "none";
				document.body.appendChild( stats.domElement );
				//
				axes = new THREE.AxisHelper(150);
				axes.material.transparent = true;
				axes.material.opacity = 0.0;
				scene.add(axes);
				//
				var canvas = depth.canvas;
				canvas.style.position = "absolute";
				canvas.style.display = "none";
				canvas.style.width = "100px";
				document.body.appendChild(canvas);

				/*
					+	: zoom camera in
					-	: zoom camera out
					C 	: change bg color
					S 	: toggle stats
				 */
				document.onkeypress = function(e){
					var e = window.event || e;
					// console.log(e.keyCode)

					if(e.keyCode==61) camera.position.z -= 25;	// +
					if(e.keyCode==45) camera.position.z += 25;	// -

					if(e.keyCode == 99 ){ // C ( to change background color )
						clearColor = (clearColor==0xffffff) ? 0x000000 : 0xffffff;
						renderer.setClearColor( clearColor );
					}
					if(e.keyCode == 115 ){ // S ( to toggle stats )
						if(stats.domElement.style.display=='none'){
							canvas.style.display  = stats.domElement.style.display = 'block';
							axes.material.opacity = 1.0;
						} else { 
							canvas.style.display  = stats.domElement.style.display = 'none';
							axes.material.opacity = 0.0;
						}
					}

				}

				window.onresize = function() {
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
					renderer.setSize( window.innerWidth, window.innerHeight );
				}
				window.onresize();

			}

			var frame = 0;
			var counter = 0;

			function draw() {
				requestAnimationFrame(draw);

				var time = performance.now();
				if( wireframe.loaded && pointcloud.loaded ){
					wireframe.mesh.rotation.y = Math.sin( time*0.0003 );
					pointcloud.mesh.rotation.y = Math.sin( time*0.0003 );
					wireframe.mesh.material.uniforms.time.value = time;
					pointcloud.mesh.material.uniforms.time.value = time;
				}
					

				counter++;
				if( counter % 240  == 0 ){
					frame++; if(frame>=KeyFrames.length) frame = 0;
					depth.crossFadeCanvasData( KeyFrames[frame], 1000 );
				}
				wireframe.update();
				pointcloud.update();

				renderer.render( scene, camera );
				stats.update();
			}



			function makegui(){
				var gui = new dat.GUI(); 
				// var f1 = gui.addFolder('u');
				// f1.add(box2, 'h', 0, 359).step(1).name('hue').listen().onChange(function(){ change(); }); 
				gui.add( pointcloud.mesh.material.uniforms.pmax, 'value', 0.0, 15.0 ).name('pmin');
				gui.add( pointcloud.mesh.material.uniforms.resthresh, 'value', -25.0, 25.0 ).step(1.0).name('resthresh');

				gui.domElement.style.zIndex = 100;				
			}

			//0.125



		</script>
	</body>
</html>