<!DOCTYPE html>
<html>
<head>
	<title>emerge-app</title>
	<link rel="stylesheet" href="css/styles.css">
</head>
<body>
	<script src="js/libs/stats.min.js"></script>
	<script src="js/libs/three.min.js"></script>
	<script src="js/libs/socket.io.js"></script>

	<script src="js/BB.min.js"></script>
	<script src="js/meshFromKinect.js"></script>

	<!-- - - - - - - - POINT SHADER - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  -->

	<script id="vs-point" type="x-shader/x-vertex">

		uniform sampler2D map;
		uniform float width;
		uniform float height;
		uniform float pointsize;
		// uniform int depth[307200];
		
		// IDEA: pass depth data directly as texture
		// uniform sampler2D depthdata;


		// float near = 20.0;	// should these be const?
		// float far  = 100.0; // should these be const? 
		float zoffset = 2048.0/4.0;

		varying vec2 vUv;
		varying vec3 vPos;
		varying vec3 vColor;
		varying float vDepth;

		void main() {

			// pass fragement-shader coords
			vPos = position; 
			// pass fragment-shader vertexColor
			vColor = color;
			// pass fragement-shader uv's ( to be used w/ texture map )
			vUv = uv;


			// // use color from canvas as z-depth 
			// vec4 depth = texture2D( map, uv );
			// depth = clamp( depth, 0.6471, 1.0 );
			// float z = (1.0-depth.r) * 2048.0; 


			// use color from canvas as z-depth 
			vec4 depth = texture2D( map, uv );
			float d = ( depth.r + depth.g ) / 2.0;
			vDepth = d; // pass to fragment shader
			d = clamp( d, 0.6471, 1.0 );
			float z = (1.0-d) * 2048.0; 


			// int i = ( uv.y * width ) + uv.x;
			// float = z (1.0 - depth[i]) * 2048.0;

			// // IDEA: pass depth data directly as texture
			// vec4 test = texture2D( depthdata, uv );
			// depth = clamp( depth, 0.6471, 1.0 );
			// float z = (1.0-depth.r) * 2048.0; 
			
			
			vec4 pos = vec4( position.x, position.y, -z+zoffset, 1.0 );
			
			gl_PointSize = pointsize;
			gl_Position = projectionMatrix * modelViewMatrix * pos;
			// gl_Position = vec4(position, 1.0); // flat screen essentially 

		}


	</script>


	<script id="fs-point" type="x-shader/x-fragment">

		uniform sampler2D map;
		varying vec2 vUv;
		varying float vDepth;

		float scale( float val, float in_min, float in_max, float out_min, float out_max ){
			return (val - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
		}
		
		void main() {
			
			//float d = (vDepth - 0.6471) / 0.3529; // scale it
			float d = scale( vDepth, 0.6471, 0.75, 0.0, 1.0 );
			

			gl_FragColor = vec4( d, d, d, 1.0 );
			// gl_FragColor = vec4( 1.0 );
		
		}

	</script>

	<!-- - - - - - - - WIRE SHADER - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  -->


	<script id="vs-wire" type="x-shader/x-vertex">

		uniform sampler2D map;

		float zoffset = 2048.0/4.0;

		void main() {
			
			vec4 depth = texture2D( map, uv );
			float d = ( depth.r + depth.g ) / 2.0;
			d = clamp( d, 0.6471, 1.0 );
			float z = (1.0-d) * 2048.0; 
			
			vec4 pos = vec4( position.x, position.y, -z+zoffset, 1.0 );
			gl_Position = projectionMatrix * modelViewMatrix * pos;


		}

	</script>

	<script id="fs-wire" type="x-shader/x-fragment">

		void main() {
			gl_FragColor = vec4(1.0,1.0,1.0,1.0);
		}

	</script>


	<!-- - - - - - - - MESH SHADER - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  -->

	<script id="vs-mesh" type="x-shader/x-vertex">

		uniform sampler2D map; // kinect canvas img
		uniform float width;
		uniform float height;

		float zoffset = 2048.0/4.0;

		varying vec2 vUv;
		varying vec3 vPos;
		varying vec3 vColor;
		varying float vDepth;

		// conolution kernal clean up 
		uniform float blr[9];

		void main() {

			// pass fragement-shader coords
			vPos = position; 
			// pass fragment-shader vertexColor
			vColor = color;
			// pass fragement-shader uv's ( to be used w/ texture map )
			vUv = uv;


			// use canvas map as z-depth 
			vec4 depth = texture2D( map, uv );
			float d = ( depth.r + depth.g ) / 2.0;
			vDepth = d; // pass to fragment shader
			d = clamp( d, 0.6471, 1.0 );
			float z = (1.0-d) * 2048.0; 

			// float z = ( 1.0 - clamp(depth.r,0.6471,1.0) ) * 2048.0;


			// r channel clamped to mid grey: 0.6471 ( see app.js threshold )
			// float r = clamp( texture2D( map, uv ).r, 0.6471,1.0); 
			// float r = tex,0.6471,1.0)ture2D(map,uv).r;

			// float r1 = texture2D(map, uv + vec2(-1, -1) ).r * blr[0];
			// float r2 = texture2D(map, uv + vec2( 0, -1) ).r * blr[1];
			// float r3 = texture2D(map, uv + vec2( 1, -1) ).r * blr[2];
			// float r4 = texture2D(map, uv + vec2(-1,  0) ).r * blr[3];
			// float r5 = texture2D(map, uv + vec2( 0,  0) ).r * blr[4];
			// float r6 = texture2D(map, uv + vec2( 1,  0) ).r * blr[5];
			// float r7 = texture2D(map, uv + vec2(-1,  1) ).r * blr[6];
			// float r8 = texture2D(map, uv + vec2( 0,  1) ).r * blr[7];
			// float r9 = texture2D(map, uv + vec2( 1,  1) ).r * blr[8]; 


			// // .... convolution maths ....
			// float colorSum = r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8 + r9;
			// float kernelWeight 	= blr[0] + blr[1] + blr[2] + blr[3] + blr[4] + blr[5] + blr[6] + blr[7] + blr[8];			 
			// if (kernelWeight <= 0.0) { kernelWeight = 1.0; }
			// float depth = colorSum / kernelWeight;

			
			vec4 pos = vec4( position.x, position.y, -z+zoffset, 1.0 );
			// vec4 pos = vec4( position.x, position.y, -500.0, 1.0 );
			

			gl_Position = projectionMatrix * modelViewMatrix * pos;
			// gl_Position = vec4(position, 1.0);

		}


	</script>

	<script id="fs-mesh" type="x-shader/x-fragment">


		uniform float time;
		uniform float leapx;
		uniform float leapy;
		uniform float width;
		uniform float height;
		uniform float blur[9];

		// texture map
		uniform sampler2D map;	  // kinect canvas texture
		uniform sampler2D canvTex; // color canvas texture
		
		// uv coords
		varying vec2 vUv;

		// position
		varying vec3 vPos;

		// vertexColor
		varying vec3 vColor;

		// zdepth color
		varying float vDepth;

		vec3 cm( vec3 c1, vec3 c2 ){
			return vec3(
				(c1.r+c2.r)/2.0,
				(c1.g+c2.g)/2.0,
				(c1.b+c2.b)/2.0
			);
		}

		void main() {

			vec4 color = texture2D( map, vUv );	// depth-map texture app.js Kinect data canvas
			vec4 c = texture2D( canvTex, vUv ); 	// color-box texture from kinectMesh internal canvas


			// // mix shifting colors w/ vectorColors
			// float r = abs( sin(  vUv.x + time / 5.0 ) );
			// float g = abs( sin(  vUv.y + time / 4.0 ) );
			// float b = abs( sin( -vUv.x + time / 3.0 ) );
			// vec3 clr = vec3(r,g,b);
			// gl_FragColor = vec4( cm(vColor,clr), 1.0 );
			
			// gl_FragColor = vec4( 
			// 	vColor.r,
			// 	vColor.g,
			// 	vColor.b,
			// 	1.0 
			// );
			
			// gl_FragColor = vec4( 
			// 	abs( sin(c.r + leapx)), 
			// 	abs( sin(c.g + leapx)), 
			// 	abs( sin(c.b + leapx)), 
			// 	0.75
			// );
			
			// // crazy rainbow color grid from canvas + leap motion
			// gl_FragColor = vec4( 
			// 	step(0.5,abs( sin(c.r + width/leapx ))),
			// 	step(0.5,abs( sin(c.g + width/leapx ))),
			// 	step(0.5,abs( sin(-c.r + width/leapx ))), 
			// 	1.0
			// );


			// // create shifting gradient across entire plane
			// float r = abs( sin(  vUv.x + time / 5.0 ) );
			// float g = abs( sin(  vUv.y + time / 4.0 ) );
			// float b = abs( sin( -vUv.x + time / 3.0 ) );
			// gl_FragColor = vec4( r, g, b, 1.0 );
			

			// // vectorColors IF dpeth-texture isn't black
			// vec3 condi = vec3( vColor.r, vColor.g, vColor.b );
			// if( color.r == 0.0 ) condi.r = 1.0;
			// if( color.g == 0.0 ) condi.g = 1.0;
			// if( color.b == 0.0 ) condi.b = 1.0;
			// gl_FragColor = vec4( condi, 1.0 );


			// // crazy rainbow color grid from canvas
			// gl_FragColor = vec4( 
			// 	step(0.5,abs( sin(c.r + time / 5.0 ))),
			// 	step(0.5,abs( sin(c.g + time / 4.0 ))),
			// 	step(0.5,abs( sin(-c.r + time / 3.0 ))), 
			// 	1.0
			// );
			
			// just canvas colrs 
			gl_FragColor = vec4( c.r, c.g, c.b, 1.0);
			 
			
			// just vectorColors
			// gl_FragColor = vec4( vColor, 1.0 );


			// gl_FragColor = vec4( vDepth, vDepth, vDepth, 1.0 );
			// gl_FragColor = vec4( color.r, color.r, color.r, 1.0 );
		}


	</script>

	<script src="app.js"></script>

</body>
</html>